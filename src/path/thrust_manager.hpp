#ifndef THRUST_MANAGER_HPP_INCLUDED
#define THRUST_MANAGER_HPP_INCLUDED

#include "../render/window.hpp"

#include "gps.hpp"

/** \brief This class is intented to perform the regulation part of the journey
 *      It uses Euler's method to integrate an interplanetary trajectory, following
 *      the given flight plan
 */

class ThrustCalculator {

public:

    ThrustCalculator(SolarSystem& system, double max_acceleration);

    struct ThrustPerformances {
        unsigned int steps_number;
        double total_delta_v;
        double time;
        bool success;
    };

    /* Simulates the trajectory generated by the GPS */
    ThrustPerformances simulate(const std::vector<GPS::Step> path, double initial_orbit_height, double final_height,
                                        VisualTrajectory* target = nullptr);

///Attributes
protected:

    //the solar system
    SolarSystem* m_sys;

    //keeping track of the path and the execution of it
    std::vector<GPS::Step> m_path;
    unsigned int m_current_step;

    //keeping track of the acceleration
    double m_max_acceleration;
    double m_consumed_delta_v;

    //keeping track of the situation of the spacecraft
    Coords m_position;
    Coords m_speed;
    double m_time;

    /*Indicates the gravitational scenario:
       - between the planets
       - next to a planet
       - is crashed */
    enum GravitationnalState{SunOrbit, FlyBy, Crashed};
    GravitationnalState m_state;
    unsigned int m_next_to; //if in FlyBy, saves which planet is next to us.

    /*A visual trajectory for the debugging*/
    VisualTrajectory* m_target;
    unsigned int m_mod;

    static const unsigned int s_sampleFrequency = 60;

    //regulation constants
    struct RegulationParameters{
        double omega_2;
        double omega_q;
        RegulationParameters(double pulsation, double quality);
    };

    static const RegulationParameters s_orbit_reg;
    static const RegulationParameters s_docking_reg;

    static constexpr double s_epsilonPos = pow(10,6);
    static constexpr double s_epsilonOrbitPos = pow(10, 4);
    static constexpr double s_epsilonSpeedFactor = 0.02;
    static constexpr double s_epsilonAngle = M_PI_4 / 4;

    //simulation constants
    static constexpr double s_interplanetaryTimeStep = 20;
    static constexpr double s_fieldTimeStep = 2;

    //performances counters
    unsigned int m_steps;


///Internal
protected:

    void clear();

    /* Is in charge between the start and the finish planet */
    bool travel();
    bool slingshot();

    /*The leaving and docking steps are quite difficult, so they deserve there own functions*/
    bool unengage();
    bool park(double final_height);

    void followOrbit(SolarSystem::GlobalSituation& sit, Elliptic_Orbit& target, RegulationParameters reg);

    void regulate(double stepping_time, SolarSystem::GlobalSituation& situation,
                Coords targetSpeed, Coords targetPos,
                RegulationParameters settings);

    void updateState(double stepping_time, SolarSystem::GlobalSituation& situation, Coords my_acceleration = NullCoords);

};

#endif // THRUST_MANAGER_HPP_INCLUDED
